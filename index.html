<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hand & Face AI Bot</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    h1 {
      margin: 10px 0;
      font-size: 24px;
      text-align: center;
    }
    #video {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
    }
    .card {
      background: rgba(0,0,0,0.5);
      border-radius: 15px;
      padding: 15px;
      margin: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      max-width: 90%;
    }
    #chat {
      flex: 1;
      width: 100%;
      max-width: 600px;
      overflow-y: auto;
    }
    .bubble {
      margin: 5px 0;
      padding: 10px 15px;
      border-radius: 20px;
      max-width: 75%;
      animation: fadeIn 0.3s ease;
    }
    .bot { background: #1e90ff; align-self: flex-start; }
    @keyframes fadeIn { from{opacity:0;transform:translateY(10px);} to{opacity:1;transform:translateY(0);} }
    #gesturesList {
      list-style: none;
      padding: 0;
    }
    #gesturesList li {
      background: rgba(255,255,255,0.1);
      margin: 5px 0;
      padding: 8px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .toggle {
      display: flex;
      align-items: center;
      gap: 6px;
    }
  </style>
</head>
<body>
  <h1>ü§ñ Hand & Face AI Bot</h1>
  <video id="video" autoplay muted playsinline></video>

  <div class="card">
    <div class="controls">
      <label class="toggle"><input type="checkbox" id="toggleHand" checked> Hand Gestures</label>
      <label class="toggle"><input type="checkbox" id="toggleFace" checked> Face Expressions</label>
      <label class="toggle"><input type="checkbox" id="toggleVoice" checked> Voice Response</label>
    </div>
  </div>

  <div class="card" style="flex:1;width:100%;max-width:600px;display:flex;flex-direction:column;">
    <div id="chat"></div>
  </div>

  <div class="card">
    <h3>Gestures</h3>
    <form id="gestureForm">
      <input type="text" id="gestureName" placeholder="Gesture name" required>
      <input type="text" id="gestureResponse" placeholder="Bot response" required>
      <button type="submit">Add Gesture</button>
    </form>
    <ul id="gesturesList"></ul>
  </div>

<script>
  const video = document.getElementById("video");
  const chat = document.getElementById("chat");
  const gesturesList = document.getElementById("gesturesList");

  // toggle switches
  const toggleHand = document.getElementById("toggleHand");
  const toggleFace = document.getElementById("toggleFace");
  const toggleVoice = document.getElementById("toggleVoice");

  let gestures = [
    {name: "open", response: "Halo!"},
    {name: "one", response: "Kalp"},
    {name: "two", response: "Nama"},
    {name: "thumbs_up", response: "Bagus!"}
  ];
  let cooldown = false;

  function addMessage(text) {
    const div = document.createElement("div");
    div.className = "bubble bot";
    div.textContent = text;
    chat.appendChild(div);
    chat.scrollTop = chat.scrollHeight;
  }

  function speak(text) {
    if (!toggleVoice.checked) return;
    const utter = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utter);
  }

  function triggerResponse(text) {
    if (cooldown) return;
    addMessage(text);
    speak(text);
    cooldown = true;
    setTimeout(()=>cooldown=false, 2000);
  }

  // Gestures UI
  function renderGestures() {
    gesturesList.innerHTML = "";
    gestures.forEach((g,i)=>{
      const li = document.createElement("li");
      li.textContent = g.name + " ‚Üí " + g.response;
      gesturesList.appendChild(li);
    });
  }
  renderGestures();

  document.getElementById("gestureForm").addEventListener("submit", e=>{
    e.preventDefault();
    const name = document.getElementById("gestureName").value;
    const res = document.getElementById("gestureResponse").value;
    gestures.push({name, response: res});
    renderGestures();
    e.target.reset();
  });

  // MediaPipe Hands
  const hands = new Hands({locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
  hands.setOptions({maxNumHands: 2, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
  hands.onResults(results=>{
    if (!toggleHand.checked) return;
    if (results.multiHandLandmarks && results.multiHandLandmarks.length>0) {
      let g = gestures.find(g=>g.name==="open");
      if (g) triggerResponse(g.response);
    }
  });

  // FaceMesh dengan jeda anti-kedip
  let lastFaceTrigger = 0;
  let eyeClosedSince = null;
  const FACE_SLEEP_THRESHOLD = 0.018; // relatif
  const YAWN_THRESHOLD = 0.05;

  function getMetric(face){
    const leftEye = Math.abs(face[159].y - face[145].y);
    const rightEye = Math.abs(face[386].y - face[374].y);
    const mouth = Math.abs(face[13].y - face[14].y);
    return {leftEye,rightEye,mouth};
  }

  const faceMesh = new FaceMesh({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
  faceMesh.setOptions({minDetectionConfidence:0.7, minTrackingConfidence:0.7});
  faceMesh.onResults(results=>{
    if (!toggleFace.checked) return;
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length>0) {
      const face = results.multiFaceLandmarks[0];
      const m = getMetric(face);
      const now = Date.now();
      const cd = 3000;

      // yawn
      if (m.mouth > YAWN_THRESHOLD) {
        if (now - lastFaceTrigger > cd){
          lastFaceTrigger = now;
          triggerResponse("Kamu kelihatan menguap, istirahat dulu ya");
        }
        eyeClosedSince = null;
        return;
      }

      // sleep detection (mata tertutup >1.5s)
      if (m.leftEye < FACE_SLEEP_THRESHOLD && m.rightEye < FACE_SLEEP_THRESHOLD){
        if (!eyeClosedSince) eyeClosedSince = now;
        else if (now - eyeClosedSince > 1500){
          if (now - lastFaceTrigger > cd){
            lastFaceTrigger = now;
            triggerResponse("Kamu mengantuk, jangan dipaksa ya");
          }
        }
        return;
      } else {
        eyeClosedSince = null;
      }
    }
  });

  const camera = new Camera(video,{
    onFrame: async ()=>{
      await hands.send({image: video});
      await faceMesh.send({image: video});
    },
    width:1280, height:720
  });
  camera.start();
</script>
</body>
</html>
ap(()=>({x:0,y:0}));
  frames.forEach(f=>{ for(let i=0;i<21;i++){ sum[i].x += f[i].x; sum[i].y += f[i].y; } });
  const n = frames.length;
  return sum.map(p=>({x:p.x/n, y:p.y/n}));
}
function compareTemplates(a,b){
  let s = 0;
  for(let i=0;i<21;i++){ s += Math.abs(a[i].x - b[i].x) + Math.abs(a[i].y - b[i].y); }
  return s;
}

/* ====== Templates UI ====== */
function renderTemplates(){
  gesturesListEl.innerHTML = templates.length ? '' : '<div class="tiny">(Belum ada gesture tersimpan)</div>';
  templates.forEach(t=>{
    const el = document.createElement('div'); el.className='gesture-item';
    const left = document.createElement('div'); left.className='gesture-left';
    left.innerHTML = `<div><b>${t.name}</b><div class="badge tiny">${t.response}</div></div>`;
    const right = document.createElement('div');
    right.innerHTML = `
      <div class="row">
        <button data-id="${t.id}" class="editBtn">‚úèÔ∏è</button>
        <button data-id="${t.id}" class="delBtn">üóëÔ∏è</button>
        <button data-id="${t.id}" class="testBtn">‚ñ∂Ô∏è Test</button>
      </div>
    `;
    el.appendChild(left); el.appendChild(right);
    gesturesListEl.appendChild(el);
  });

  // handlers
  document.querySelectorAll('.delBtn').forEach(b=>{
    b.onclick = ()=>{ const id=b.dataset.id; templates = templates.filter(x=>x.id!==id); renderTemplates(); };
  });
  document.querySelectorAll('.editBtn').forEach(b=>{
    b.onclick = ()=>{
      const id=b.dataset.id; const t = templates.find(x=>x.id===id); if(!t) return;
      const newName = prompt('Ubah nama gesture', t.name); if(newName===null) return;
      const newResp = prompt('Ubah respon suara', t.response); if(newResp===null) return;
      const newCd = prompt('Cooldown (ms) untuk gestur ini', t.cooldown||gestureCooldownInput.value); if(newCd===null) return;
      t.name = newName || t.name; t.response = newResp || t.response; t.cooldown = parseInt(newCd)|| (parseInt(gestureCooldownInput.value)||2500);
      renderTemplates();
    };
  });
  document.querySelectorAll('.testBtn').forEach(b=>{
    b.onclick = ()=>{ const id=b.dataset.id; const t = templates.find(x=>x.id===id); if(t) speak(t.response); };
  });
}

/* ====== Save / Export / Import / Clear ====== */
saveBtn.onclick = ()=>{
  if(!recordFrames.length){ alert('Rekam gesture dulu (tombol Rekam).'); return; }
  const avg = averageFrames(recordFrames);
  if(!avg){ alert('Gagal merekam.'); return; }
  const normalized = normalizeLandmarks(avg);
  const name = gestureNameInput.value.trim() || autoNameFromTemplate(normalized);
  const response = gestureResponseInput.value.trim() || prompt('Masukkan respon suara untuk gestur ini:') || 'Halo';
  const cooldown = parseInt(gestureCooldownInput.value) || 2500;
  const id = 'g'+Date.now().toString(36);
  templates.push({id,name,response,cooldown,landmarks:normalized,lastTriggered:0});
  recordFrames = []; recording = false;
  statusEl.innerText = `‚úÖ Gestur "${name}" tersimpan. (${templates.length} total)`;
  renderTemplates();
};

exportBtn.onclick = ()=>{
  const data = JSON.stringify(templates);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='gestures.json'; a.click();
};

importBtn.onclick = ()=> importFile.click();
importFile.onchange = (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = ev=>{
    try{
      const data = JSON.parse(ev.target.result);
      if(Array.isArray(data)){
        templates = data.map(d=>({...d, lastTriggered:0}));
        renderTemplates();
        statusEl.innerText = '‚úÖ Import sukses.';
      } else alert('Format JSON tidak valid');
    }catch(err){ alert('File JSON tidak valid'); }
  };
  reader.readAsText(f);
};

clearBtn.onclick = ()=>{
  if(confirm('Hapus semua gesture?')){ templates=[]; renderTemplates(); statusEl.innerText='Semua gesture dihapus'; }
};

/* ====== Auto-name heuristic ====== */
function autoNameFromTemplate(norm){
  try{
    const tips = [4,8,12,16,20], pips = [3,6,10,14,18];
    let ext = 0;
    for(let i=0;i<5;i++){ if(norm[tips[i]].y < norm[pips[i]].y) ext++; }
    if(ext>=4) return 'open_palm';
    if(ext===0) return 'fist';
    return `${ext}_fingers`;
  }catch(e){ return 'gesture_'+Date.now().toString(36); }
}
btnAutoName.onclick = ()=>{
  if(!recordFrames.length){ alert('Rekam gesture dulu.'); return; }
  const avg = averageFrames(recordFrames);
  const name = autoNameFromTemplate(normalizeLandmarks(avg));
  gestureNameInput.value = name;
};

/* ====== Recording controls ====== */
btnRecord.onclick = ()=>{ recording = true; recordFrames = []; statusEl.innerText = '‚è∫Ô∏è Merekam gesture... tahan sampai selesai.'; };
btnStopRecord.onclick = ()=>{ recording = false; statusEl.innerText = '‚èπÔ∏è Rekaman dihentikan. Klik Simpan Gestur untuk menyimpan.'; };

/* ====== Snapshot ====== */
btnSnapshot.onclick = ()=>{
  const temp = document.createElement('canvas'); temp.width = canvas.width; temp.height = canvas.height;
  const tctx = temp.getContext('2d');
  tctx.save(); tctx.scale(-1,1); tctx.drawImage(video, -temp.width, 0, temp.width, temp.height); tctx.restore();
  tctx.drawImage(canvas, 0, 0, temp.width, temp.height);
  temp.toBlob(blob=>{
    const url = URL.createObjectURL(blob);
    downloadLink.href = url; downloadLink.download='snapshot.png'; downloadLink.click();
  }, 'image/png', 0.95);
};

/* ====== Fullscreen ====== */
btnFullscreen.onclick = async ()=>{
  const el = document.getElementById('videoWrap');
  try{
    if(!document.fullscreenElement) await el.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){ console.warn('Fullscreen error', e); }
};

/* ====== Detection (Hands & Face) ====== */

/* helpers for face heuristics */
function faceMetrics(landmarks){
  // landmarks in normalized coords (x,y,z) length ~468
  // mouth open: distance between upper lip (13) and lower lip (14) or 13 & 14
  const upperLip = landmarks[13];
  const lowerLip = landmarks[14];
  const mouthOpen = Math.hypot((upperLip.x-lowerLip.x), (upperLip.y-lowerLip.y));

  // eye openness (left & right): use landmarks (159,145) and (386,374) approximations
  const leftTop = landmarks[159], leftBottom = landmarks[145];
  const rightTop = landmarks[386], rightBottom = landmarks[374];
  const leftEye = Math.hypot(leftTop.x-leftBottom.x, leftTop.y-leftBottom.y);
  const rightEye = Math.hypot(rightTop.x-rightBottom.x, rightTop.y-rightBottom.y);
  // brow vs eye: distance between brow (10-ish) and eye to detect frown/sad (approx)
  const leftBrow = landmarks[65], rightBrow = landmarks[295];
  const leftFrown = Math.hypot(leftBrow.x-leftTop.x, leftBrow.y-leftTop.y);
  const rightFrown = Math.hypot(rightBrow.x-rightTop.x, rightBrow.y-rightTop.y);

  return { mouthOpen, leftEye, rightEye, leftFrown, rightFrown };
}

/* face cooldown & thresholds */
const FACE_YAWN_THRESHOLD = 0.055; // adjust if needed
const FACE_SLEEP_THRESHOLD = 0.015; // eye openness small => sleepy
const FACE_SAD_THRESHOLD = 0.02; // brow proximity changed

let faceMesh = null;
let hands = null;
let cam = null;

/* main hands onResults (multi-hand support) */
function onHandsResults(results){
  // ensure canvas size
  canvas.width = video.videoWidth || 640;
  canvas.height = video.videoHeight || 480;
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  // draw face overlays if we have face landmarks saved by face callback (faceDrawing happens elsewhere)
  // draw hands
  if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
    results.multiHandLandmarks.forEach((lm, idx)=>{
      // color by hand index
      const color = idx===0 ? '#00ffb3' : '#66d9ff';
      window.drawConnectors(ctx, lm, window.HAND_CONNECTIONS, {color:color, lineWidth:3});
      window.drawLandmarks(ctx, lm, {color:'#ffd600', lineWidth:2, radius:3});

      statusEl.innerText = `üëÄ ${results.multiHandLandmarks.length} tangan terdeteksi`;

      // process frame for recording or recognition
      const simple = lm.map(p=>({x:p.x, y:p.y}));
      if(recording){
        recordFrames.push(simple);
        if(recordFrames.length >= RECORD_FRAME_COUNT){
          recording = false;
          statusEl.innerText = '‚úÖ Rekaman selesai. Klik Simpan Gestur.';
        } else {
          statusEl.innerText = `‚è∫Ô∏è Merekam... (${recordFrames.length}/${RECORD_FRAME_count||RECORD_FRAME_COUNT})`;
        }
      } else {
        // recognition: normalize current and compare with templates
        if(templates.length>0){
          const normCurrent = normalizeLandmarks(simple);
          let best=null, bestDist=Infinity;
          for(const t of templates){
            const d = compareTemplates(t.landmarks, normCurrent);
            if(d < bestDist){ bestDist = d; best = t; }
          }
          const threshold = parseFloat(sensitivityRange.value) || 3.0;
          if(best && bestDist < threshold){
            const now = Date.now();
            const tcd = best.cooldown || (parseInt(gestureCooldownInput.value) || 2500);
            if(!best.lastTriggered) best.lastTriggered = 0;
            if(now - best.lastTriggered > tcd){
              best.lastTriggered = now;
              flashHighlight();
              speak(best.response);
              statusEl.innerText = `‚úÖ Gesture "${best.name}" terdeteksi (score ${bestDist.toFixed(2)})`;
            } else {
              statusEl.innerText = `üîí Gesture "${best.name}" cocok tetapi on cooldown`;
            }
          }
        }
      }
    });
  } else {
    statusEl.innerText = 'üëÄ Tidak ada tangan';
  }
  ctx.restore();
}

/* face callback */
function onFaceResults(results){
  // draw small face landmarks overlay
  if(results.multiFaceLandmarks && results.multiFaceLandmarks.length>0){
    const face = results.multiFaceLandmarks[0];
    // optional: draw mesh lightly
    window.drawConnectors(ctx, face, window.FACEMESH_TESSELATION, {color:'#ffffff22', lineWidth:1});
    const m = faceMetrics(face);
    const now = Date.now();
    const faceCd = parseInt(faceCooldownInput.value) || 3000;

    // yawn detection
    if(m.mouthOpen > FACE_YAWN_THRESHOLD){
      if(now - lastFaceTrigger > faceCd){
        lastFaceTrigger = now;
        speak('Kamu kelihatan menguap, istirahat dulu ya');
        statusEl.innerText = 'üòÆ Terlihat menguap';
      }
      return;
    }

    // sleepy detection (both eyes small)
    if(m.leftEye < FACE_SLEEP_THRESHOLD && m.rightEye < FACE_SLEEP_THRESHOLD){
      if(now - lastFaceTrigger > faceCd){
        lastFaceTrigger = now;
        speak('Kamu mengantuk, jangan dipaksa ya');
        statusEl.innerText = 'üò¥ Terlihat mengantuk';
      }
      return;
    }

    // sad detection heuristic: brows closer to eyes (smaller leftFrown/rightFrown) or mouth corners slightly down
    if(m.leftFrown < FACE_SAD_THRESHOLD || m.rightFrown < FACE_SAD_THRESHOLD){
      if(now - lastFaceTrigger > faceCd){
        lastFaceTrigger = now;
        speak('Kamu kelihatan sedih, semoga harimu segera membaik');
        statusEl.innerText = 'üòî Terlihat sedih/murung';
      }
      return;
    }

    // else clear face status if nothing
    // (do not override hand message)
  }
}

/* flash highlight */
function flashHighlight(){
  const vb = document.getElementById('videoWrap');
  vb.classList.add('highlight');
  setTimeout(()=>vb.classList.remove('highlight'), 420);
}

/* ====== MediaPipe & Camera init ====== */
hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
hands.onResults(onHandsResults);

faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
faceMesh.onResults(onFaceResults);

async function startCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720}, audio:false});
    video.srcObject = stream;
    await video.play();
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    cameraObj = new Camera(video, {
      onFrame: async () => {
        // send both to hands and faceMesh
        await hands.send({image: video});
        await faceMesh.send({image: video});
      },
      width: video.videoWidth,
      height: video.videoHeight
    });
    cameraObj.start();
    btnCamera.innerText = 'Stop Camera';
    statusEl.innerText = '‚úÖ Kamera berjalan';
  }catch(err){
    console.error(err); alert('Gagal akses kamera: ' + err.message); statusEl.innerText = '‚ùå Gagal akses kamera';
  }
}
function stopCamera(){
  if(cameraObj){ cameraObj.stop(); cameraObj = null; }
  if(video.srcObject){ video.srcObject.getTracks().forEach(t=>t.stop()); video.srcObject=null; }
  btnCamera.innerText = 'Start Camera';
  statusEl.innerText = 'Kamera dihentikan';
}
btnCamera.onclick = ()=> { if(!cameraObj) startCamera(); else stopCamera(); };

/* init */
renderTemplates();

/* keyboard shortcuts */
document.addEventListener('keydown', (e)=>{
  if(e.key==='r') btnRecord.click();
  if(e.key==='s') btnStopRecord.click();
});

/* apply settings button hook (simple acknowledgement) */
applySettingsBtn.onclick = ()=> { statusEl.innerText = 'Settings applied.'; };

/* small compatibility: ensure RECORD_FRAME_COUNT ref works in messages */
const RECORD_FRAME_count = RECORD_FRAME_COUNT;
</script>
</body>
</html>
